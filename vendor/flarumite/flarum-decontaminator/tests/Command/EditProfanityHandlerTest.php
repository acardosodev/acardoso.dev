<?php

/*
 * This file is part of flarumite/flarum-decontaminator.
 *
 * Copyright (c) 2020 Flarumite.
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Flarumite\Tests\Decontaminator\Command;

use Flarum\User\Exception\PermissionDeniedException;
use Flarumite\PostDecontaminator\Command\EditProfanity;
use Flarumite\PostDecontaminator\Command\EditProfanityHandler;
use Flarumite\PostDecontaminator\PostDecontaminatorRepository;
use Flarumite\PostDecontaminator\PostDecontaminatorValidator;
use Flarumite\Tests\Decontaminator\AbstractHandlerTest;
use Flarumite\Tests\Decontaminator\Stubs\PostDecontaminatorModel;
use Flarumite\Tests\Decontaminator\Traits\ProfanityTestTrait;
use Flarumite\Tests\Decontaminator\Traits\UserTestTrait;
use Illuminate\Database\Eloquent\ModelNotFoundException;
use Illuminate\Validation\ValidationException;

class EditProfanityHandlerTest extends AbstractHandlerTest
{
    use UserTestTrait;
    use ProfanityTestTrait;

    public $attributesArray;
    public $newAttributesArray;

    public function setUp(): void
    {
        parent::setUp(); // TODO: Change the autogenerated stub
        $this->attributesArray = [
            'id'          => 1,
            'name'        => 'Rule',
            'regex'       => '/strawberry/mi',
            'replacement' => 'raspberry',
            'flag'        => true,
            'event'       => false,
        ];

        $this->newAttributesArray = [
            'id'          => 1,
            'name'        => 'Ruling',
            'regex'       => '/edited/mi',
            'replacement' => 'changed',
            'flag'        => false,
            'event'       => true,
        ];
    }

    /**
     * @group unit
     */
    public function testActorWithPermissionCanEditProfanity()
    {
        $actor = $this->getAdminActor();

        $this->postDecontaminatorModel->shouldReceive('build')
            ->andReturn($this->getAttributes());
        $this->postDecontaminatorModel->shouldReceive('getDirty')
            ->andReturn($this->newAttributesArray);

        $command = $this->getMockBuilder(EditProfanity::class)
            ->enableOriginalConstructor()
            ->setConstructorArgs([1, $actor, $data = [
                'attributes' => $this->newAttributesArray,
                'original'   => $this->attributesArray,
            ]])
            ->getMock();

        $repository = $this->getMockBuilder(PostDecontaminatorRepository::class)
            ->setMethods(['findOrFail'])
            ->getMock();

        $repository->method('findOrFail')
            ->willReturn($this->postDecontaminatorModel->build());

        $validator = $this->getMockBuilder(PostDecontaminatorValidator::class)
            ->disableOriginalConstructor()
            ->setMethods(['assertValid'])
            ->getMock();

        $validator->method('assertValid')
            ->withAnyParameters()
            ->willReturn('true');

        $commandHandler = new EditProfanityHandler($repository, $validator);

        $profanity = $commandHandler->handle($command);

        $this->assertEquals($this->newAttributesArray['id'], $profanity->id);
        $this->assertEquals($this->newAttributesArray['name'], $profanity->name);
        $this->assertEquals($this->newAttributesArray['regex'], $profanity->regex);
        $this->assertEquals($this->newAttributesArray['replacement'], $profanity->replacement);
        $this->assertEquals($this->newAttributesArray['flag'], $profanity->flag);
        $this->assertEquals($this->newAttributesArray['event'], $profanity->event);
        $this->assertEquals($this->attributesArray['id'], $profanity->id);
        $this->assertNotEquals($this->attributesArray['name'], $profanity->name);
        $this->assertNotEquals($this->attributesArray['regex'], $profanity->regex);
        $this->assertNotEquals($this->attributesArray['replacement'], $profanity->replacement);
        $this->assertNotEquals($this->attributesArray['flag'], $profanity->flag);
        $this->assertNotEquals($this->attributesArray['event'], $profanity->event);
    }

    /**
     * @group unit
     */
    public function testActorWithoutPermissionCannotEditProfanityThrowsException(): void
    {
        $this->expectException(PermissionDeniedException::class);

        $actor = $this->getActor();

        $command = $this->getMockBuilder(EditProfanity::class)
            ->enableOriginalConstructor()
            ->setConstructorArgs([1, $actor, []])
            ->getMock();

        $repository = $this->createMock(PostDecontaminatorRepository::class);

        $validator = $this->createMock(PostDecontaminatorValidator::class);

        $commandHandler = new EditProfanityHandler($repository, $validator);
        $commandHandler->handle($command);
    }

    /**
     * @group unit
     */
    public function testModelNotFoundExceptionIsThrownIfProfanityDoesNotExist()
    {
        $this->expectException(ModelNotFoundException::class);

        $actor = $this->getAdminActor();

        $command = $this->getMockBuilder(EditProfanity::class)
            ->enableOriginalConstructor()
            ->setConstructorArgs([1, $actor, $data = [
                'attributes' => $this->attributesArray,
            ]])
            ->getMock();

        $repository = $this->getMockBuilder(PostDecontaminatorRepository::class)
            ->setMethods(['findOrFail'])
            ->getMock();

        $repository->method('findOrFail')
            ->willThrowException(new ModelNotFoundException());

        $validator = $this->getMockBuilder(PostDecontaminatorValidator::class)
            ->disableOriginalConstructor()
            ->setMethods(['assertValid'])
            ->getMock();

        $validator->method('assertValid')
            ->withAnyParameters()
            ->willThrowException(new ModelNotFoundException());

        $commandHandler = new EditProfanityHandler($repository, $validator);
        $commandHandler->handle($command);
    }

    /**
     * @group unit
     */
    public function testHandleWithInvalidAttributesThrowsValidationException()
    {
        $this->expectException(ValidationException::class);

        $actor = $this->getAdminActor();

        $this->postDecontaminatorModel->shouldReceive('build')
            ->andReturn($this->getAttributes());
        $this->postDecontaminatorModel->shouldReceive('getDirty')
            ->andReturn($this->newAttributesArray);

        $command = $this->getMockBuilder(EditProfanity::class)
            ->enableOriginalConstructor()
            ->setConstructorArgs([1, $actor, $data = [
                'attributes' => $this->newAttributesArray,
                'original'   => $this->attributesArray,
            ]])
            ->getMock();

        $repository = $this->getMockBuilder(PostDecontaminatorRepository::class)
            ->setMethods(['findOrFail'])
            ->getMock();

        $repository->method('findOrFail')
            ->willReturn($this->postDecontaminatorModel->build());

        $validator = $this->getMockBuilder(PostDecontaminatorValidator::class)
            ->disableOriginalConstructor()
            ->setMethods(['assertValid'])
            ->getMock();

        $validator->method('assertValid')
            ->willThrowException(new ValidationException($validator));

        $commandHandler = new EditProfanityHandler($repository, $validator);

        $commandHandler->handle($command);
    }

    public function getAttributes()
    {
        $response = new PostDecontaminatorModel();
        foreach ($this->attributesArray as $key => $value) {
            $response->$key = $value;
        }

        return $response;
    }
}
